### 事务

在事务进行过程中，未结束之前，DML语句是不会更改底层数据，只是将历史操作记录一下，在内存中完成记录。只有在事物结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据

#### 事务的控制：

##### 开启

- 手动：

    ```SQL
    start transaction;
    ```

- 自动：只要执行一条DML语句就开启了事物，并且提交了事务

##### 提交

- 手动：

    ```SQL
    commit;
    ```

- 自动：只要执行一条DML语句就开启了事物，并且提交了事务

##### 回滚

- 手动：

    ```SQL
    rollback;
    ```

- 自动：只要执行一条DML语句就开启了事物，当出现错误时，自动回滚事务

事务的四大特性：__原子性(A)、一致性(C)、隔离性(I)、持久性(D)__

- 原子性：一个事务中的所有操作，要么全部成功，要么全部失败
- 一致性：在事务开始和事务结束以后，数据库的完整性没有被破坏
- 隔离性：防止多个事务并发执行时由于交叉执行而导致数据的不一致
- 持久性：事务结束后，对数据的修改就是永久的

| 特性   | 原理                       |
| ------ | -------------------------- |
| 原子性 | 通过undo log回滚日志来保证 |
| 一致性 | 通过undo log回滚日志来保证 |
| 隔离性 | 通过锁机制保证             |
| 持久性 | 通过redo log重做日志来保证 |

#### 隔离级别

隔离级别从低到高分为：__读未提交(READ-UNCOMMITTED)、读已提交(READ-COMMITTED)、可重复读(REPEATABLE-READ)、串行化(SERIALIZABLE)__，MySQL __默认为可重复读__

- 读未提交：允许读取尚未提交的数据变更：事务A和事务B，事务A未提交的数据，事务B可以读取到
- 读已提交：允许读取并发事务已经提交的数据：事务A和事务B，事务A提交的数据，事务B才能读取到
- 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改：事务A和事务B，事务A提交之后的数据，事务B读取不到
- 串行化：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰：事务A和事务B，事务A在操作数据库时，事务B只能排队等待

#### 隔离级别的并发问题

- 脏读：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
- 不可重复读：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据
- 幻读：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的

##### 隔离级别与一致性关系

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | :--: | :--------: | :--: |
| 读未提交 |  √   |     √      |  √   |
| 读已提交 |  X   |     √      |  √   |
| 可重复读 |  X   |     X      |  √   |
| 串行化   |  X   |     X      |  X   |

##### 隔离级别配置

- 配置`my.ini`文件的 transaction-isolation 项来设置缺省事务隔离级别

```SQL
transaction-isolation=READ-COMMITTED
```

- 使用 SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL 语句来动态设置事务隔离级别

```SQL
SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

##### 隔离级别作用范围

- 全局级：对所有的会话有效

```SQL
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED；
```

- 会话级：只对当前的会话有效

```SQL
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED；
```
