### 锁

在数据库有并发事务的时候，通过锁机制来保证访问的次序，以达到安全、保证数据一致性目的。

### 隔离级别 & 锁

| 隔离级别         | 锁                                                           |
| ---------------- | ------------------------------------------------------------ |
| read uncommitted | 读操作不需要加共享锁，这样就不会和写操作上的排他锁冲突       |
| read committed   | 读操作需要加共享锁，但是语句执行完成后会释放共享锁           |
| repeatable read  | 读操作需要加共享锁，但是只有在整个事务完成后才会释放共享锁   |
| serializable     | 限制性最强的隔离级别，__锁定整个范围的建__，并一直持有锁，直到事务完成 |

### 锁分类

#### 行锁

行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为行共享锁和行排他锁

-   特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高

#### 表锁

表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享锁与排他锁

-   特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低

#### 页锁

页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

-   特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

#### 总结

| 锁   | 开销 | 枷锁速度 | 死锁 | 冲突概率 | 并发速度 |
| ---- | :--: | :------: | :--: | :------: | :------: |
| 行锁 |  大  |    慢    |  会  |    低    |    高    |
| 表锁 |  小  |    快    | 不会 |    高    |    低    |
| 页锁 |  中  |    中    |  会  |    中    |   一般   |

### 锁的实现

### 锁的算法

InnoDB中锁的算法有三种：

| 算法          | 说明                                    |
| ------------- | --------------------------------------- |
| record lock   | 单个行记录上的锁                        |
| gap lock      | 间隙锁                                  |
| next-key lock | record + gap 锁定一个范围，包含记录本身 |

##### 相关

- innodb对于行的查询使用：next-key lock
- Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
- next-key lock为了解决Phantom Problem幻读问题
- 当查询的索引含有唯一属性时，将next-key lock降级为record key
- 有两种方式显式关闭gap锁：
    1. 将事务隔离级别设置为read committed
    2. 设置`innodb_locks_unsafe_for_binlog=1`

### 死锁

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象

##### 解决

1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率