## 索引

索引是为了加快对数据的搜索速度而设立的。它能够改善检索操作的性能，但是会降低数据更改的性能。索引是scheme中的一个数据库对象，与表独立存放。索引的创建有两种情况：

- 自动：当在标上定义一个主键或者唯一约束条件时，oracle数据库会创建一个对应的唯一索引
- 手动：通过关键字创建索引

### 作用

- 在数据库中用来加速对表的查询，通过使用快速路径访问方法快速定位数据，减少磁盘IO

### 索引的触发方式

BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：

```SQL
-- 只要它的查询条件是一个不以通配符开头的常量
select * from user where name like 'jack%'; 
-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： 
select * from user where name like '%jack'; 
```

### 索引的设计原则

- 适合索引的列是出现在where子句中的列，或者连接子句中指定的列
- 基数较小的类，索引效果较差，没有必要在此列建立索引
- 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
- 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。

### 索引的创建原则

- 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如`a=1 and b=2 and c>3 and d=4` 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- 较频繁作为查询条件的字段才去创建索引
- 更新频繁字段不适合创建索引
- 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
- 定义有外键的数据列一定要建立索引。
- 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
- 对于定义为text、image和bit的数据类型的列不要建立索引。

### 局部性原理

经常访问的数据和经常访问的代码往往会聚集在一起，局部性分为两种：

- 空间局部性：经常用的、经常被访问的数据会被尽快的放在一起
- 时间局部性：热点数据

### 磁盘预读

在读取磁盘文件时，即使是只读取一个字节的数据，也会将这个字节所属的页一起读取到内存中，一页为4KB

### 索引的分类

##### 主键索引

主键是一种唯一性索引，但它必须指定为 __PRIMARY KEY__，每个表只能有一个主键

##### 唯一索引

索引列的所有值都只能出现一次，即必须唯一，值可以为空

##### 普通索引

基本的索引类型，值可以为空，没有唯一性的限制

##### 全文索引

全文索引的索引类型为 __FULLTEXT__，全文索引可以在varchar、char、text类型列上创建

##### 组合索引

多个列组成一个索引，专门用于组合搜索

### 数据结构

MySQL采用B+树存储索引

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628132401.png)

##### 为什么用B+树不用hash表

- hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询
- hash索引不支持使用索引进行排序，原理同上
- hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性
- hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询
- hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低

##### 为什么用B+树不用B树

- B树只适合随机检索，而B+树同时支持随机检索和顺序检索
- B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素
- B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当
- B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作
- 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率

### 回表

在InnoDB中，是通过B+树结构对主键创建索引，然后在叶子结点中以key(主键)-value(记录)形式存储数据；如果没有主键，那么会选择唯一键；如果没有唯一键，那么会自动生成一个6位的row_id来作为主键。此时，如果某张表中的索引有非主键列，那么该索引的叶子结点中存储存储格式位：key(索引列)-value(主键)。在查找时，要先通过普通列索引找到对应的数据(key)和主键(value)，然后再根据主键查找主键索引拿到对应的记录。这种场景下会经过两次B+树(普通列索引+主键列索引)的遍历工作，这种行为被称为 __回表__

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628132810.png)

### 索引覆盖

explain的输出结果Extra字段为Using index时，能够触发索引覆盖。通俗来讲就是 __只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。__
例如以下这张表：

``` 建表
create table user (
  id int primary key,
  name varchar(20),
  sex varchar(5),
  index(name)
)engine=innodb;
```

第一个SQL语句：`explain select id,name from user where name='zhangsan';`
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628132845.png)<br>
能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。

第二各SQL语句：`select id,name,sex from user where name='shenjian';`
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628132905.png)<br>
能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫码聚集索引获取sex字段，效率会降低。

### 联合索引

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为：先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整

### 最左前缀 & 最左匹配

- 顾名思义，就是最左优先，在创建组合索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如`a=1 and b=2 and c>3 and d=4` 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- = 和 in 可以乱序，比如`a=1 and b=2 and c=3` 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

### 谓词下推

### 索引下推

在回表之前就已经根据条件对数据进行了一次删选和删除，从而提高执行的效率