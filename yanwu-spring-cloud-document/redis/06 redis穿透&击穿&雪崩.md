#### 穿透

>   穿透指K对应的数据在数据库中并不存在，每次针对K的请求从缓存中取不到，请求都会到数据库，从而压垮数据库。比如使用id为负数去获取信息，不论是缓存还是数据库都没有，所以每次都会去数据库里查一次，缓存失去意义。

##### 解决方案

- 布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免数据库的压力。
- 如果一个条件查询返回的结果为空（不论是数据不存在还是系统故障），我们仍然把这个空结果进行缓存，然后把它的过期时间设置短一些。



#### 击穿

>   击穿指K对应的数据非常热点，访问非常频繁，当这个K过期的瞬间，此时如果有大量的请求过来，这些请求发现缓存没有数就会从数据库中查询数据并回设到缓存，这个时候大并发的请求可能会瞬间把数据库压垮。

##### 解决方案

- 使用互斥锁（mutex），就是在缓存失效的时候（判断拿出来的值为空），不是立即去load DB，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load DB的操作并回设缓存；否则，就重试整个get缓存的方法。
- 将热点数据设置为永不过期



#### 雪崩

>   雪崩指缓存服务器重启或缓存中大量数据在某一时间段过期，然后系统涌入大量的查询请求，因为大部分数据在缓存中已经失效，请求渗透到数据库，引起数据库压力造成查询堵塞甚至宕机。

##### 解决方案

- 将缓存失效时间分散，比如每个K的过期时间是随机的，让缓存失效的时间点尽量均匀，防止同一时间大量数据过期的现象发生；
- 如果缓存和数据库是分布式部署，将热点数据均匀的分布在不同的redis和数据库中，分担压力；
- 做二级缓存或者双缓存策略（A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期）
- 最简单粗暴的方式是让redis数据永不过期