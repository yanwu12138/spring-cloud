https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

https://visualgo.net/zh


# [树（Tree）](https://www.cnblogs.com/maybe2030/p/4732377.html)
树：是n个结点的有限集。没有元素称之为空树，在任意一个非空树中，有以下特点：
- 有且仅有一个 __根结点__
- 当结点数大于1时，其余结点可以分为m个互不相交的有限集，其中每一个集合本身又是一棵树，称之为 __子树__
- 结点拥有的子树数目称之为 __度__
- 结点子树的根结点为该结点的 __孩子结点__，相应的该结点成为孩子结点的 __双亲结点__
- 同一个双亲结点的孩子结点之间互称 __兄弟结点__
- __结点层次__：从根结点开始起，根为第一层，根的孩子结点为第二层，以此类推
- 树种结点的最大层次数称之为书的 __深度或高度__

***
## 二叉树
二叉树是`n(n>=0)`个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140601.png)

### 特点
- 每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。
- 左子树和右子树是有顺序的，次序不能任意颠倒。
- 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

### 性质
- 在二叉树的第 i 层上最多有 `2^{i-1}` 个结点。(i>=1)
- 二叉树中如果深度为 k，那么最多有 `2^{k}-1` 个结点。(k>=1）
- `n_0=n_2+1`，`n_0`表示度数为0的结点数，`n_2`表示度数为2的结点数。
- 在 __完全二叉树__ 中，具有n个结点的完全二叉树的深度为`[log_2n]+1`，其中`[log_2n]`是向下取整。
- 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：
    - 若 i = 1，则该结点是二叉树的根，无双亲，否则，编号为 `[i/2]` 的结点为其双亲结点;
    - 若 2i > n，则该结点无左孩子， 否则，编号为 `2i` 的结点为其左孩子结点；
    - 若 2i + 1 > n，则该结点无右孩子结点，否则，编号为 `2i+1` 的结点为其右孩子结点。

### 斜树
- 左斜树：所有的结点都只有左子树的二叉树
- 右斜树：所有的结点都只有右子树的二叉树

### 二叉树的储存结构
#### 顺序存储
二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140637.png)

#### 二叉链表
既然顺序存储不能满足二叉树的存储需求，那么考虑采用链式存储。由二叉树定义可知，二叉树的每个结点最多有两个孩子。因此，可以将结点数据结构定义为一个数据和两个指针域。

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140653.png)

### 二叉树遍历
二叉树的遍历是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。
二叉树的访问次序可以分为四种：前序遍历、中序遍历、后序遍历、层序遍历

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140710.png)

#### 前序遍历：父结点 > 左子树 > 右子树
前序遍历通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。
```java
public void preOrder(Node<E> node) {
    if (node == null) {
        return;
    }
    System.out.println(node.item);
    preOrder(node.leftChild);
    preOrder(node.rightChild);
}
```

#### 中序遍历：左子树 > 父结点 > 右子树
中序遍历就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。
```java
public void inOrder(Node<E> node) {
    if (node == null) {
        return;
    }
    inOrder(node.leftChild);
    System.out.println(node.item);
    inOrder(node.rightChild);
}
```

#### 后序遍历：左子树 > 右子树 > 父结点
就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。
```java
private void postOrder(Node<E> node) {
    if (node == null) {
        return;
    }
    postOrder(node.leftChild);
    postOrder(node.rightChild);
    System.out.println(node.item);
}
```

### 满二叉树 & 完全二叉树
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140736.png)
#### 满二叉树
除最后一层无任何子节点外，每一层上的所有节点都有两个子节点。除了叶子节点外所有的节点均为两个子节点，节点数达到最大值，所有叶子节点必须在同一层上
##### 性质：一个树深度为n，最大层数为k
- 深度与最大层数相同
- 叶子节点为 `2^h`
- 第k层的节点数是：`2^{k-1}`
- 总节点数是：`2^k-1`，且总节点数一定是奇数

#### 完全二叉树
假设二叉树的深度为h，除第h层外，其它各层的节点数都达到最大个数，第h层所有的节点都连续集中在最左边

***
## 二叉查找树
又称二叉排序树或二叉搜索树，二叉查找树的时间复杂度和二分查找一样，插入和查找的时间复杂度均为`O(logn)`，但是在最坏的情况下仍然会有`O(n)`的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

#### 定义：
- 若左子树不为空，则左子树上所有的节点的值均小于它的根节点的值
- 若右子树不为空，则右子树上所有的节点的值均大于它的根结点的值
- 左右子树也分别为二叉查找树
- 没有键值相等的节点

#### 性质：
- 对二叉查找树进行中序遍历，即可得到有序的数列
- 二叉查找树的深度决定了二叉查找树的过程

#### 二叉查找树的删除，分三种情况处理
- 当要删除的节点为叶子节点，直接删除，再修改其父节点的指针

    ![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140802.png)

- 当要删除的节点为单支节点，让该节点的子树与父树节点相连，然后删除即可

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140840.png)

- 当要删除的节点 __z__ 左右子树都不为空，此时有两种方式：
    - 找到 __z__ 的后继节点 __y__，因为 __y__ 一定没有左子树，所以删除 __y__，然后将 __y__ 的父节点成为 __y__ 的右子树的父节点，用 __y__ 替换 __z__，然后删除 __z__ 即可
    - 找到 __z__ 的前驱节点 __x__，因为 __x__ 一定没有右子树，所以删除 __x__，然后将 __z__ 的父节点成为 __x__ 的左子树的父节点，用 __x__ 替换 __z__，然后删除 __z__ 即可

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140854.png)

***
## 平衡二叉树
又称为AVL树，对于一般的二叉搜索树，其期望高度为`log_2n`，其各操作的时间复杂度`O(log_2n)`同时也由此而决定。但是在有些极端的情况下（比如在插入的序列是有序时），二叉搜索树将退化成链表，此时其操作的时间复杂度将退化成线性的，既`O(n)`。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次操作之后，由于在删除时，饿哦们总是选择将待删节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于向左偏沉，这是也会造成树的平衡性破坏，提高它操作的时间复杂度。平衡二叉树就是为了解决该问题而生。

#### 特质
- 它是一棵空树或者它的左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一颗平衡二叉树
- 平衡二叉树的常用算法有红黑树、AVL树等

在最小的平衡二叉树的节点的公式如下：
> ` F(n) = F(n-1) + F(n-2) + 1 ` 其中：1 是根节点，`F(n-1)`是左子树的节点数量，`F(n-2)`是右子树的节点数量

### 平衡二叉树 > [AVL树](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)
AVL树是最先发明的自平衡二叉查找树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis。在AVL中任何节点的左右两个子树的高度差绝对值不超过1，所以它也被称为 __高度平衡树__，增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在`O(logN)`。但是频繁旋转会使插入和删除牺牲掉`O(logN)`左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

#### AVL树的自平衡操作--旋转
AVL树最关键的也是最难的一步操作就是旋转。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140917.png)
- 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为 __左左__。
- 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为 __左右__。
- 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为 __右左__。
- 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为 __右右__。

从上图中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为 __单旋转__。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为 __双旋转__。

##### 单旋转
单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。下图是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140937.png)

为使树恢复平衡，我们把k1变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。

这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。

##### 双旋转
对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。下图是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树D深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141001.png)

为使树恢复平衡，我们需要进行两步：
- 第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况
- 第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树

### 平衡二叉树 > [红黑树](https://www.jianshu.com/p/e136ec79235c)
红黑树是每个节点都带有颜色属性的平衡二叉查找树，颜色为红色或黑色。，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，称之为"对称二叉B树"。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在`O(logn)`时间内做查找，插入和删除，这里的`n`是树中元素的数目。

红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（RealTimeApplication）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。此外，红黑树还是2-3-4树的一种等同，它们的思想是一样的，只不过红黑树是2-3-4树用二叉树的形式表示的。

#### 性质
1. 节点是红色或者黑色
2. 根是黑色
3. 所有叶子节点都是黑色的空节点（NIL）
4. 每个红色节点必须有两个黑色子节点，也就是说从每个叶子到根的所有路径上不能同时有两个连续的红色节点
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141018.png)

这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

#### 红黑树的自平衡操作
因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量`(O(logn))`的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为`O(logn)`次。

我们首先以二叉查找树的方法增加节点并标记它为红色。如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的（违背性质5）。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（colorFlips）和树旋转来调整。下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。注意:
- 性质1和性质3总是保持着
- 性质4只在增加红色节点、重绘黑色节点为红色、做旋转时受到威胁
- 性质5只在增加黑色节点、重绘黑色节点为空色、做旋转时受到威胁

##### 左旋
以某个节点作为支点（旋转节点），支点的右子节点变为支点的父节点，右子节点的左子节点变为支点的右子节点，左子节点保持不变

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141038.png)

##### 右旋
以某个节点作为支点（旋转节点），支点的左子节点变为支点的父节点，左子节点的右子节点变为支点的左子节点，右子节点保持不变

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141052.png)

##### 变色
节点颜色由红变黑或由黑边红

###### 结论
我们先忽略颜色，可以看到旋转操作不会影响支点的父结点，父结点以上的结构还是保持不变的。<br>
__左旋__ 只影响支点和其 __右子树__ 的结构，把右子树的节点向左子树挪动了<br>
__右旋__ 只影响支点和其 __左子树__ 的结构，把左子树的节点向右子树挪动了<br>
所以旋转操作是局部的：当一边子树的节点少了，就向另一边子树借一些节点；当一边子树节点多了，就向另一边子树租一些节点。

##### 查找
因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找没有区别：

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141109.png)

##### 插入
插入操作分为两个部分：
- 找到插入的位置，将节点插入
- 自平衡：当节点插入后，将刚插入的节点颜色标记为红色，因为在父节点（如果存在）为黑色节点时，红黑树的平衡没有被破坏，不需要做自平衡操作；但是如果插入的节点是黑色，那么插入的位置所在的子树黑色节点总是多1，必须做自平衡。红黑树插入后自平衡操作分为以下几种情况：

###### [红黑树的插入](https://www.processon.com/view/link/5ee3346907912929cb3e19a2)分为以下几种场景：[示例](https://www.processon.com/view/link/5eead57707912929cb4b34d0)
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141127.png)
###### 插入情景4.1
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141152.png)
###### 插入情景4.2.1 & 插入情景4.2.2
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141210.png)
###### 插入情景4.3.1 & 插入情景4.3.2
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141223.png)

##### 删除
红黑树的烧出操作也包括两个部分：
- 找到目标结点，然后将目标结点删除
- 自平衡：查找目标结点就是普通的查找方式，当不存在目标结点时，忽略这次删除操作；当存在目标结点时，删除后就得左自平衡处理了。而且删除了结点后我们还需要找结点来替代删除节点的位置，不然子树和父结点断开了，除非删除结点刚好是叶结点，那么就不需要替代。
    - 二叉树删除结点找替代结点有3中情景：
        1. 删除结点为叶结点，直接删除
        2. 删除结点只有一个子结点，用子结点替代
        3. 删除结点有两个子结点，用后继结点（删除结点的右子树的最左结点）替代

删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点，如图：在不看键值的情况下，红黑树最终结果是删除了Q所在位置的节点

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141245.png)



基于上面所述的3中二叉树的删除情景可以相互转换并且最终都是转换为情景1：
- 情景2：删除结点用其唯一的子结点替换，子结点替换为删除节点后，可以认为删除的是子结点，如果此时子结点又有两个子结点，那么相当于转换为场景3，一直自顶向下转换，总是能转为情景1
- 情景3：删除结点用后继结点，如果后继节点有右子结点，那么相当于转换为情景2，否则转换为情景1

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141316.png)

综上所述，__删除操作的删除结点可以看作删除替代结点，而替代节点最后总是在树末（叶结点）__，有了这个结论，删除红黑树的情景就少了很多，因为我们只考虑删除叶结点的情景就可以了

###### [红黑树的删除](https://www.processon.com/view/link/5ee3346907912929cb3e19a2)分为以下几种场景
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141350.png)
###### 情景2.1.1
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141413.png)
###### 情景2.1.2.1
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141442.png)
###### 情景2.1.2.2
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141532.png)
###### 情景2.1.2.3
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141547.png)
###### 情景2.2.1
![clipboard (1)](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141605.png)
###### 情景2.2.2.1
![clipboard (2)](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141617.png)
###### 情景2.2.2.2
![clipboard (3)](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141627.png)
###### 情景2.2.2.3
![clipboard (4)](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141638.png)
###### 删除示例
![clipboard (5)](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141703.png)

***
## B树 & B+树 & B*树
### B树
B树也是一个用于查找的平衡树，但它不是二叉树
#### 定义
B树是一种树状的数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作都在对数时间内完成。B树概括来说是一个一般化的二叉查找树，可以拥有多于两个子结点。与自平衡二叉查找树不同，B树为系统最优化大块数据的读写。

#### B树的查找
在B树的查找给定关键字的方法是：首先把根节点取出来，在根节点包含的关键字`k_1...k_n`（可用二分查找），如果找到给定的关键字，则查找成功；否则一定可以确定要查找的关键字在`k_i...k_{i+1}`之间，`p_i`为指向子树根结点的指针，此时取指针`p_i`所指结点继续查找，直至找到或者`p_i`为空查找失败为止。

#### 特性：
B树是一种多路搜索树，定义任意非叶子结点最多只有`M`个儿子，且`M > 2`
- 根结点的儿子个数为`[2, M]`
- 除根结点以外的非叶子结点的儿子个数为`[M/2, M]`
- 每个结点至少存放`M/2-1`和之多`M-1`个关键字（至少两个关键字）
- 非叶子结点的关键字个数 = 指向儿子的指针个数 - 1
- 非叶子结点的关键字：`k_1，k_2...k_{M-1}`，且`k_i<k_{i+1}`
- 非叶子结点的指针`p_1，p_2...p_m`，其中`p_1`指向关键字小于`k_1`的子树，`p_m`指向关键字大于`k_{m-1}`的子树，其它`p_i`指向关键字属于`(k_{i-1}，k_i)`的子树
- 所有叶子节点位与同一层

##### 如下图为一个M=3的B树示例：
![btreebuild B-](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141739.gif)

### B+树
B+树是B树的变体，也是一种多路搜索树
#### 定义：其定义基本与B数相同，除了以下几点：
- 非叶子结点的子树指针与关键字个数相同
- 非叶子结点的子树指针`p_i`，指向关键字值属于`[k_i，k_{i+1})`的子树（B树是开区间）
- 为所有叶子结点增加一个链指针
- 所有关键字都在叶子结点出现

#### 特性：
B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的
- 不可能在非叶子结点命中
- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
- 更适合文件索引系统

##### 如下图为一个M=3的B+树示例：
![btreebuild B+](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628141800.gif)

### B*树
B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从`1/2`提高到`2/3`。

B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；

所以，B*树分配新结点的概率比B+树要低，空间使用率更高。

## LSM