## 什么是redis
redis是基于内存的一个key-value的数据库，通常用来作为缓存使用。

## redis有哪些数据类型
redis有五种数据类型：
- string
- hash
- list
- set
- zset（sorted-set）

##### [跳表](https://www.jianshu.com/p/54d37710b2a6)
##### ![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628135827.png)为什么快
- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速
- 数据结构简单，对数据操作也简单
- 采用单线程，避免了不必要的上下文切换和竞争条件
- 使用多路I/O复用模型，非阻塞IO

##### 多路复用
redis 内部使用文件事件处理器，这个文件事件处理器是单线程的，所以redis才叫做单线程的模型。它采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。文件事件处理器的结构包含 4 个部分：
- 多个socket
- IO多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理

## redis的优势
- 由于是基于内存的，所以redis读写速度快
- 支持丰富的数据类型（5种）
- 支持事务的原子性

## redis与memcached
- memcache只支持string，redis可以支持多种数据类型
- memcache无法进行持久化，redis可以支持持久化
- memcache是多核的，redis是核的
- 都支持主从，但redis的主从是做备份的，memcache的主从都可以进行读写

## [持久化](https://www.cnblogs.com/xiaoqiang-code/p/11748395.html)
#### RDB（redis database）：数据快照【默认】
RDB是内存中的数据生成快照文件（dump.rdb）持久化到硬盘
##### RDB持久化有两种方式：
- 当redis满足一定的条件时，会自动触发save指令同步快照。比如：60秒之内有1000个键被更改或定时1个小时执行，当条件满足时，会自动持久化
- 通过save、bgsave指令手动进行持久化。每次执行save、bgsave命令，都会生成一个新的快照文件覆盖旧的快照文件

|命令|同步异步|是否阻塞|优点|缺点|
|---|---|---|---|---|
|save|同步|是|不会消耗额外的内存|阻塞客户端的指令|
|bgsave|异步|是（在fork时阻塞）|不阻塞客户端的指令|需要fork，消耗内存|

#### AOF（append-only file）：日志文件
AOF是以日志文件的形式持久化，针对客户端的每一条写命令，都会将对应的写命令写到appendonly.aof文件中。通过修改配置文件来打开AOF持久化功能：
```bash
appendonly yes
```
##### AOF主要有三种方式：
- always：每次的写操作都直接写到AOF文件
- everysyc：每秒钟写一次
- no：不做控制，由系统自行控制是否写日志文件

| 方式     | 优点           | 缺点             |
| -------- | -------------- | ---------------- |
| always   | 所有的数据都在 | 慢，IO开销大     |
| everysyc | 每秒写一次     | 会丢失一秒的操作 |
| no       | 使用简单       | 不可控           |

#### RDB & AOF区别

| 方式 | 启动优先级 | 体积 | 恢复速度 |  数据安全性  |
| :--: | :--------: | :--: | :------: | :----------: |
| RDB  |     低     |  大  |    快    |  容易丢数据  |
| AOF  |     高     |  小  |    慢    | 根据策略决定 |

#### RDB + AOF（redis4.0 - 混合模式）
重启redis恢复数据集时，很少会使用rdb来恢复内存状态，因为会丢失大量数据。通常会使用aof日志恢复数据，但是重放aof日志性能相对rdb来说要慢很多，这样在redis实例很大的情况下，启动需要花费很长时间。为了解决这个问题，redis4.0带来了新的持久化选项—— __混合持久化__。通过配置的方式开启。
```bash
aof-use-rdb-preamble yes
```
如果开启了混合持久化，aof在重写时，不再是单纯将内存数据转换为RESP命令写入aof文件，而是将重写这一刻之前的内存做rdb快照处理，并且将rdb快照内容和增量的aof修改内存数据的命令存在一起，都写入新的aof文件，新的aof文件一开始不叫appendonly.aof，等到重写完成后，新的aof文件才会进行改名，原子的覆盖原有的aof文件，完成新旧两个aof文件的替换。<br>
于是在redis重启的时候，可以先加载rdb文件，然后再重放增量的aof日志就可以完全替代之前的aof全量文件重放，因此重启效率大幅得到提高。

## 过期策略
redis过期策略分为三种：定时删除、惰性删除、定期删除
- 定时删除：在设置过期时间时，redis会同步生成一个定时器，等定时器时间到了自动删除对应的数据
- 惰性删除：设置过期时间后，只会在你访问到数据的时候判断数据是否过期，如果过期，则将数据删除，如果数据没过期，则进行访问
- 定期删除：设置过期时间后，每隔一段时间轮询一次数据是否过期，如果过期，则将数据删除

| 策略     | 优点                                                         | 缺点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定时删除 | 能够保证内存尽快地被释放掉                                   | 1.如果同一时间大批量数据过期，会同时进行数据删除占用CPU，导致阻塞<br>2.每设置一个过期时间，都要生成一个定时器，影响性能 |
| 惰性删除 | 删除操作只发生在从数据库取数据的时候，而且只对该K进行操作，所以对CPU的占比较小 | 如果大量的数据过期后没有去访问，可能会导致内存泄露（垃圾数据过多） |
| 定期删除 | 1.解决定时删除的CPU占用问题和性能问题<br>2.解决惰性删除的内存泄漏问题 | 在内存友好方面不如定时删除，在CPU时间友好方面不如惰性删除    |

## 内存淘汰策略
redis的内存淘汰策略是指在redis的用于缓存的内存不足时，怎么处理需要写入且申请额外空间的数据
- noeviction：当内存不足时，新写入操作会报错
- allkeys-lru：当内存不足时，在键空间中，移除最近最少使用的K
- allkeys-random：当内存不足时，在键空间中，随机移除K
- volatile-lru：当内存不足时，在设置了过期时间的键空间中，移除最近最少使用的K
- volatile-random：当内存不足时，在是指了过期时间的键空间中，随机移除K
- volatile-ttl：当内存不足据时，在设置了过期时间的键空间中，优先移除更早过期时间的K

## 穿透 & 击穿 & 雪崩
#### 穿透
穿透指K对应的数据在数据库中并不存在，每次针对K的请求从缓存中取不到，请求都会到数据库，从而压垮数据库。比如使用id为负数去获取信息，不论是缓存还是数据库都没有，所以每次都会去数据库里查一次，缓存失去意义。

##### 解决方案
- 布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免数据库的压力。
- 如果一个条件查询返回的结果为空（不论是数据不存在还是系统故障），我们仍然把这个空结果进行缓存，然后把它的过期时间设置短一些。

#### 击穿
击穿指K对应的数据非常热点，访问非常频繁，当这个K过期的瞬间，此时如果有大量的请求过来，这些请求发现缓存没有数就会从数据库中查询数据并回设到缓存，这个时候大并发的请求可能会瞬间把数据库压垮。

##### 解决方案
- 使用互斥锁（mutex），就是在缓存失效的时候（判断拿出来的值为空），不是立即去load DB，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load DB的操作并回设缓存；否则，就重试整个get缓存的方法。
- 将热点数据设置为永不过期

#### 雪崩
雪崩指缓存服务器重启或缓存中大量数据在某一时间段过期，然后系统涌入大量的查询请求，因为大部分数据在缓存中已经失效，请求渗透到数据库，引起数据库压力造成查询堵塞甚至宕机。

##### 解决方案
- 将缓存失效时间分散，比如每个K的过期时间是随机的，让缓存失效的时间点尽量均匀，防止同一时间大量数据过期的现象发生；
- 如果缓存和数据库是分布式部署，将热点数据均匀的分布在不同的redis和数据库中，分担压力；
- 做二级缓存或者双缓存策略（A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期）
- 最简单粗暴的方式是让redis数据永不过期

## 主从复制 & 哨兵 & 集群