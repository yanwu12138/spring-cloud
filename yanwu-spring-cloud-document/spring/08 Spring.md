# Spring
### 架构的发展历程

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628140008.png)

#### 单一应用架构
当网站流浪很小时，只需要一个应用，将所有功能都部署在一起，减少部署成本，此时用于简化增删改查工作量的数据访问框架（ORM）是关键

#### 垂直应用架构
当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率，此时用于加速前端页面开发的WEB框架（MVC）是关键

#### 分布式服务架构
当垂直应用越来越多，应用之间交互比可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求，此时用于提高业务复用及整合的分布式服务框架（RPC）是关键

#### 流动计算架构
当服务越来越多，容量的评估，小服务资源的浪费问题逐渐显现，此时需要增加一个调度中心基于访问压力管理集群容量，提高集群利用率，此时用于提高机器利用率的资源调度和治理中心（SOA）是关键

## [IoC](https://www.cnblogs.com/xdp-gacl/p/4249939.html)：控制反转
Ioc是一种将对象的创建、销毁、使用一系列权利都交给Spring来管理的设计思想，DI是该思想的一种具体实现，而存放这些对象的地方被称之为容器。IoC可以用来降低程序之间的耦合度。

- 谁控制谁：在IoC之前，需要自己去控制需要使用对象，IoC之后，就会变成IoC容器来控制这些对象
- 控制什么：实现过程中所需要使用的对象及其需要依赖的对象
- 什么是反转：在IoC之前，需要手动去创建需要使用的对象，IoC之后，则是IoC容器来创建这些对象，由主动创建转变为被动接收
- 哪些方面被反转了：所依赖对象的创建、销毁等操作被反转了

##### IoC的几个基本点
> 1. ApplicationContext就是IoC容器的接口，可以通过此对象获取容器中创建的对象
> 2. 对象在IoC容器创建完成的时候就已经创建完成，不是需要用的时候才创建
> 3. 对象在IoC容器中存储的时候都是单例的，如果需要多例的话需要修改属性：`scope = prototype`
> 4. 创建对象给属性赋值的时候是通过setter函数注入的
> 5. 对象的属性是由setter函数决定的，而不是定义的成员属性

### 注入方式
- set方法注入：

    > 根据setter函数注入，其name得属性值由setter函数后的字符串决定）

    ```xml
    <bean id="myTestBean" class="com.yanwu.demo.spring.source.read.MyTestBean">
        <property name="testStr" value="aaa"/>
    </bean>
    ```

- 接口注入：

- 构造方法注入：

    > 根据对应的构造方法去设置属性值，其name的属性值由构造方法的参数列表决定，当name省略时；constructor-arg的顺序必须和构造函数的顺序保持一致；如果非要不一致的话，可以通过index的下标的方式来指定，index从0开始

    ```xml
    <bean id="myTestBean" class="com.yanwu.demo.spring.source.read.MyTestBean">
        <constructor-arg name="testStr" value="aaa" />
    </bean>
    ```

### 对象的单例与多例

可以通过scope属性来指定当前bean的作用域

| 作用域          | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| singleton：单例 | 从IoC容器中获取的都是同一个对象，默认的作用域，该实例会在IoC容器初始化之前完成创建 |
| prototype：多例 | 从IoC容器中获取的对象每次都是新创建的，该实例只会在每次需要使用的时候才会被创建 |
| request：请求   | 每次发送请求都会有一个新的对象（__Spring5已经废弃__）        |
| session：会话   | 每一次会话都会创建一个新的对象（__Spring5已经废弃__）        |

#### IoC容器初始化过程

1. Resource资源定位：Resource指的是BeanDefintion的资源定位，这个过程是容器找数据的过程
2. BeabDefinition载入过程：把用户定义好的Bean表示成IoC容器内部的数据结构
3. 向IoC容器注册这些BeanDefinition：将之前载入好的BeanDefinition保存到HashMap中

## [AOP](https://blog.csdn.net/baomw/article/details/84262006)：切面编程

面向切面编程是基于面向对象编程思想的基础之上的。AOP在程序运行期间，将某段代码动态切入到指定方法的指定位置进执行。它用一种被称之为“横切”的技术将涉及多业务流程的通用功能抽取并单独封装，形成独立的切面，在合适的时机将切面横向切入到业务流程制定的位置中。

![img](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628170310.jpeg)

##### 切面（aspect）

切入业务流程的一个独立模块，对横切关注点的抽象

##### 连接点（joinPoint）

被拦截到的点

##### 切入点（pointcut）

对连接点进行拦截的定义

##### 增强（advice）

拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕增强五类

| 通知                      | 说明                                                         |
| :------------------------ | :----------------------------------------------------------- |
| 前置增强：@Before         | 在目标方法执行之前执行执行的增强                             |
| 后置增强：@AfterReturning | 是在方法正常返回后执行的增强，如果方法没有正常返回回--例如抛出异常，则后置增强不会执行 |
| 异常增强：@AfterThrowing  | 在目标方法抛出异常时执行的增强                               |
| 最终增强：@After          | 最终增强无论如何都会在目标方法调用过后执行，即使目标方法没有正常的执行完成 |
| 环绕增强：@Around         | 在目标方法执行之前和之后都可以执行额外代码的增强             |

##### 目标对象

代理的目标对象

##### 织入（weave）

将切面应用到目标对象并导致代理对象创建的过程

##### 引入（introduction）

再不修改代码的前提下，引入可以在运行期为类动态的添加一些方法或字段



### Spring创建代理的规则

- __默认使用Java动态代理__，这样可以为任何接口实力创建代理
- __当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理__，也可以强制使用CGLIB代理：`<aop:config proxy-target-class>`



#### CGLIB代理



### 增强处理

增强处理就是在AOP框架为普通业务组件织入的处理动作，换言之就是通知



### 声明式事务

#### 事务的传播特性

当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行？

Spring的事务传播行为有7种

| 传播行为     | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| REQUIRED     | 如果有事务正在运行，当前的方法就在这个事务内运行，否则，就新起一个事务，并在自己的事务内运行 |
| REQUIRED_NEW | 当前方法必须新起事务，并在它自己的事务内运行，如果有事务正在运行，应该讲它挂起 |
| SUPPORTS     | 如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中 |
| NOT_SUPPORTS | 当前方法不应该运行在事务中，如果有运行的事务，讲它挂起       |
| MANDATORY    | 当前方法必须运行在事务内部，如果没有运行的事务，就抛出异常   |
| NEVER        | 当前方法不应该运行在事务中，如果有运行的事务，就抛出异常     |
| NESTED       | 如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行 |



***
# Spring MVC

***
# Spring boot



##### 启动

```shell
nohup java -jar xxx.jar > log-$(date +%Y-%m-%d-%H-%M).file 2>&1 &
```



***
# Spring cloud