## MySQL基本架构图
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628130918.png)

### 连接器
负责根客户端建立连接，获取权限、维持和管理连接
- 用户名密码验证
- 查询权限信息，分配对应的权限
- 可以使用 show processlist查看现在的连接
- 如果长时间没有活动，会自动断开连接（通过wait_timeout控制，默认8小时）

### 查询缓存（不建议使用且8.0后不提供）
当执行查询语句的时候，会先查询缓存中又没有结果，如果有则返回，执行后续操作，并将结果设入查询缓存
##### 问题：
- 查询缓存的缓存失效比较频繁，只要表更新，缓存就会清空
- 缓存对应的更新的数据命中率比较低

### 分析器
- 词法分析：把输入的字符串进行识别每个部分代表什么意思，例如：把 字符串ID 识别成 列ID
- 语法分析：判断SQL语句是否满足MySQL的语法，如果不符合会报错：You have error in your SQL synta

### 优化器
在具体执行SQL语句之前，要先经过优化器的处理，不同的执行方式对SQL语句的执行效率影响很大
- 当表中有多个索引的时候，决定用那个索引
- 当SQL语句需要做多表关联的时候，决定表的连接顺序

##### 优化器类型：
###### RBO（Rule Based Optimizer）：基于规则优化
> 简单说基于规则的优化就是当数据库执行一条query语句的时候必须遵循预先定义好的一系列规则（比如[oracle的15条规则](https://docs.oracle.com/cd/B10501_01/server.920/a96533/rbo.htm#38960)，排名越靠前的执行引擎认为效率越高）来确定执行过程，它不关心访问表的数据分布情况，仅仅凭借规则经验来确定，所以说是一种比较粗放的优化策略。

###### CBO（Cost Based Optimizer）：基于成本优化
> 基于代价的优化的产生就是为了解决上面RBO的弊端，让执行引擎依据预先存储到数据库中表的一些实时更新的统计信息来选择出最优代价最小的执行计划来执行query语句，CBO会根据统计信息来生成一组可能被使用到的执行计划，进而估算出每个计划的代价，从而选择出代价最小的交给执行器去执行，其中表的统计信息一般会有表大小，行数，单行长度，单列数据分布情况，索引情况等等。

###### 总结：
> 基于规则的优化器更像是一个经验丰富熟知各条路段的老司机，大部分情况可以根据自己的经验来判断走哪条路可以更快的到达目的地；而基于代价的优化更像手机里面的地图，它可以选择出许多不同的路径根据实时的路况信息综合考虑路程长度，交通状况来挑出最优的路径。

### 执行器
执行SQL语句返回结果

***
## 数据类型
### 数值
| 类型         | 大小（byte） | 含义       |
| ------------ | :----------: | ---------- |
| TINYINT      |      1       | 整数       |
| SMALLINT     |      2       | 整数       |
| MEDIUMINT    |      3       | 整数       |
| INT或INTEGER |      4       | 整数       |
| BIGINT       |      8       | 整数       |
| FLOAT        |      4       | 单精度浮点 |
| DOUBLE       |      8       | 双精度浮点 |
|DECIMAL|对DECIMAL(M,D)： 如果M>D，为M+2否则为D+2|小数

### 日期和时间
| 类型      | 大小（byte） | 含义     | 格式                |
| --------- | :----------: | -------- | ------------------- |
| DATE      |      3       | 日期     | YYYY-MM-DD          |
| TIME      |      3       | 时间     | HH:MM:SS            |
| YEAR      |      1       | 年分     | YYYY                |
| DATETIME  |      8       | 日期时间 | YYYY-MM-DD HH:MM:SS |
| TIMESTAMP |      4       | 时间戳   | YYYYMMDD HHMMSS     |

### 字符串
| 类型       | 最大值（byte） | 含义                            |
| ---------- | :------------: | ------------------------------- |
| CHAR       |      255       | 定长字符串                      |
| VARCHAR    |     65535      | 变长字符串                      |
| TINYBLOB   |      255       | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   |      255       | 短文本字符串                    |
| BLOB       |     65 535     | 二进制形式的长文本数据          |
| TEXT       |     65 535     | 长文本数据                      |
| MEDIUMBLOB |   16 777 215   | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT |   16 777 215   | 中等长度文本数据                |
| LONGBLOB   | 4 294 967 295  | 二进制形式的极大文本数据        |
| LONGTEXT   | 4 294 967 295  | 极大文本数据                    |

***
## 命令
### 数据库
| 命令 | 示例                                           |
| ---- | ---------------------------------------------- |
| 创建 | `CREATE DATABASE IF NOT EXISTS DATABASE_NAME;` |
| 删除 | `DROP DATABASE DATABASE_NAME;`                 |
| 切换 | `USE DATABASS_NAME;`                           |

### 数据表
| 命令       | 示例                                                    |
| ---------- | ------------------------------------------------------- |
| 创建       | `CREATE TABLE IF NOT EXISTS TABLE_NAME (CLOUMN TYPE);`  |
| 删除       | `DROP TABLE TABLE_NAME;`                                |
| 清空       | `TRUNCATE TABLE TABLE_NAME;`                            |
| 修改表名   | `ALTER TABLE TABLE_NAME_1 RENAME TO TABLE_NAME_2;`      |
| 添加表字段 | `ALTER TABLE TABLE_NAME ADD CLOUMN CLOUNM;`             |
| 删除表字段 | `ALTER TABLE TABLE_NAME DROP CLOUMN;`                   |
| 修改表字段 | `ALTER TABLE TABLE_NAME CHANGE CLOUMN_1 CLOUMN_2 TYPE;` |

### 索引
| 命令             | 示例                                                         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 创建索引         | `CREATE INDEX INDEX_NAME ON TABLE_NAME(CLOUMN(LENGTH));`     | 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length |
| 创建表时直接指定 | `CREATE TABLE TABLE_NAME(CLOUMN... INDEX [TABLE_NAME] (CLOUMN(LENGTH)));` | 同上                                                         |
| 修改索引         | `ALTER TABLE TABLE_NAME ADD INDEX INDEX_NAME(CLOUMN);`       | 同上                                                         |
| 删除索引         | `DROP INDEX [INDEX_NAME] ON TABLE_NAME;`                     | 无                                                           |
| 查看索引         | `SHOW INDEX FROM TABLE_NAME;`                                | 无                                                           |

### 超键、候选键、主键、外键
- 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键
- 候选键：是最小超键，即没有冗余元素的超键
- 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值
- 外键：在一个表中存在的另一个表的主键称此表的外键

### 约束分类

| 约束          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| `NOT NULL`    | 控制字段的内容一定不能为空（NULL）                           |
| `UNIQUE`      | 控制字段内容必须唯一，一个表允许有多个Unique约束             |
| `PRIMARY KEY` | 主键约束，控制字段不能重复，但它在一个表只允许出现一个       |
| `FOREIGN KEY` | 外键约束，预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一 |
| `CHECK`       | 用于控制字段的值范围                                         |

### 连接
#### 内连接
##### 内连接
获取两个表中字段匹配关系的记录：
`select * from table_a as a inner join table_b as b on a.id = b.id`

#### 外连接（LEFT JOIN/RIGHT JOIN）
##### 左连接
获取左表所有记录，即使右表没有对应匹配的记录：
`select * from table_a as a left join table_b as b on a.id = b.id`

##### 右连接
与左连接相反，用于获取右表所有记录，即使左表没有对应匹配的记录：
`select * from table_a as a right join table_b as b on a.id = b.id`

#### 联合查询（UNION与UNION ALL）
就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并：`select * from table_a as a union select * from table_b as b`

#### 全连接（FULL JOIN）
MySQL不支持全连接，但是可以LEFT JOIN 和UNION和RIGHT JOIN联合使用：`select * from table_a as a left join table_b as b on a.id = b.id union select * from table_a as a right join table_b as b on a.id = b.id;`

### SQL执行顺序
```sql
SELECT DISTINCT <select_list>
FROM <left_table>
<join_type> JOIN <right_table> ON <join_condition>
WHERE <where_condition>
GROUP BY <group_by_list>
WITH {CUBE|ROLLUP}
HAVING <having_condition>
ORDER BY <order_by_condition>
LIMIT <limit_number>

-- SQL关键字的执行顺序
-- FROM：对FROM子句中的左表<left_table>和右表<right_table>执行笛卡儿积，产生虚拟表VT1;
-- ON：对虚拟表VT1进行ON筛选，只有那些符合<join_condition>的行才被插入虚拟表VT2;
-- JOIN：如果指定了OUTER JOIN(如LEFT OUTER JOIN、RIGHT OUTER JOIN)，那么保留表中未匹配的行作为外部行添加到虚拟表VT2，产生虚拟表VT3。如果FROM子句包含两个以上的表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1~步骤3，直到处理完所有的表;
-- WHERE：对虚拟表VT3应用WHERE过滤条件，只有符合<where_condition>的记录才会被插入虚拟表VT4;
-- GROUP BY：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5;
-- CUBE|ROLLUP：对VT5进行CUBE或ROLLUP操作，产生表VT6;
-- HAVING：对虚拟表VT6应用HAVING过滤器，只有符合<having_condition>的记录才会被插入到VT7;
-- SELECT：第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中;
-- DISTINCT：去除重复，产生虚拟表VT9;
-- ORDER BY：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10;
-- LIMIT：取出指定街行的记录，产生虚拟表VT11，并返回给查询用户
```
### in & exists
###### in：把外表和内表作hash 连接
###### exists：对外表作loop循环，每次loop循环再对内表进行查询
##### 使用场景
- 如果查询的两个表大小相当，那么用in和exists差别不大
- 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in
- 如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引
- 而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快

***
## 事务
> 在事务进行过程中，未结束之前，DML语句是不会更改底层数据，只是将历史操作记录一下，在内存中完成记录。只有在事物结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据

### 事务的控制：
##### 开启
- 手动：start transaction;
- 自动：只要执行一条DML语句就开启了事物，并且提交了事务

##### 提交
- 手动：commit;
- 自动：只要执行一条DML语句就开启了事物，并且提交了事务

##### 回滚
- 手动：rollback;
- 自动：只要执行一条DML语句就开启了事物，当出现错误时，自动回滚事务

事务的四大特性：__原子性(A)、一致性(C)、隔离性(I)、持久性(D)__
- 原子性：一个事务中的所有操作，要么全部成功，要么全部失败
- 一致性：在事务开始和事务结束以后，数据库的完整性没有被破坏
- 隔离性：防止多个事务并发执行时由于交叉执行而导致数据的不一致
- 持久性：事务结束后，对数据的修改就是永久的

| 特性   | 原理                       |
| ------ | -------------------------- |
| 原子性 | 通过undo log回滚日志来保证 |
| 一致性 | 通过undo log回滚日志来保证 |
| 隔离性 | 通过锁机制保证             |
| 持久性 | 通过redo log重做日志来保证 |

### 隔离级别
隔离级别从低到高分为：__读未提交(READ-UNCOMMITTED)、读已提交(READ-COMMITTED)、可重复读(REPEATABLE-READ)、串行化(SERIALIZABLE)__，MySQL __默认为可重复读__
- 读未提交：允许读取尚未提交的数据变更：事务A和事务B，事务A未提交的数据，事务B可以读取到
- 读已提交：允许读取并发事务已经提交的数据：事务A和事务B，事务A提交的数据，事务B才能读取到
- 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改：事务A和事务B，事务A提交之后的数据，事务B读取不到
- 串行化：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰：事务A和事务B，事务A在操作数据库时，事务B只能排队等待

### 隔离级别的并发问题
- 脏读：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
- 不可重复读：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据
- 幻读：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的

#### 隔离级别与一致性关系
| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | :--: | :--------: | :--: |
| 读未提交 |  √   |     √      |  √   |
| 读已提交 |  X   |     √      |  √   |
| 可重复读 |  X   |     X      |  √   |
| 串行化   |  X   |     X      |  X   |

#### 隔离级别配置
- 配置my.ini文件的transaction-isolation项来设置缺省事务隔离级别
```
transaction-isolation=READ-COMMITTED
```
- 使用 SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL 语句来动态设置事务隔离级别
```
SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

#### 隔离级别作用范围
- 全局级：对所有的会话有效
```
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED；
```
- 会话级：只对当前的会话有效
```
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED；
```

***
### 数据库三范式
1. 每个列都不可以再拆分
2. 在第一范式的基础上，非主键列完全依赖于主键，而不能只依赖主键的一部分
3. 在第二范式的基础上，非之间只能依赖主键，不能依赖其它非主键

### binlog的三种录入形式
1. statement：每条修改数据的sql都会记录带binlog中，不需要记录每一行的变化，减少了binlog的日志量，节约IO，由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
2. row：不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大
3. mixed：一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row

***
## 引擎
### MyISAM & InnoDB & memory
#### MyISAM
InnoDB引擎提供了数据库ACID事务的支持，并且提供了行锁和外键的约束

#### InnoDB：
不提供事务，支持表锁

#### memory：
所有的数据在内存中，处理速度快，但是安全性不高

##### InnoDB和MyISAM索引的区别
InnoDB和MyISAM都是使用 B+树，InnoDB是索引组织表，MyISAM是堆表
- 索引组织表：数据存储是把表按照索引的方式存储的，数据是有序的，数据的位置是预先定好的，与插入的顺序没有关系，__查询快，修改慢__
- 堆表：数据插入时时存储位置是随机的，主要是数据库内部块的空闲情况决定，获取数据是按照命中率计算，全表扫表时不见得先插入的数据先查到，__修改快，查询慢__

| 引擎   | 事务   | 锁     | MVCC   | 外键   | 全文索引 | 多种行格式 | 其它       |
| ------ | ------ | ------ | ------ | ------ | -------- | ---------- | ---------- |
| InnoDB | 支持   | 行级锁 | 支持   | 支持   | 不支持   | 支持       | 索引组织表 |
| MyISAM | 不支持 | 表级锁 | 不支持 | 不支持 | 支持     | 不支持     | 堆表       |

### InnoDB的四大特性
- 插入缓冲
- 二次写
- 自适应哈希
- 预读

### InnoDB的事务与日志
#### 日志
- redo log：在页修改的时候，先写到redo log buffer里面，然后写到redo log的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（fsync）
- undo log：在操作任何数据之前，首先将数据备份到redo log buffer里面，然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态

#### 事务如何通过日志来实现
基本流程如下：因为事务在修改页时，要先记undo，在记undo之前要记undo的redo， 然后修改数据页，再记数据页修改的redo。Redo（里面包括undo的修改） 一定要比数据页先持久化到磁盘。当事务需要回滚时，因为有undo，可以把数据页回滚到前镜像的状态，崩溃恢复时，如果redo log中事务没有对应的commit记录，那么需要用undo把该事务的修改回滚到事务开始之前。 如果有commit记录，就用redo前滚到该事务完成时并提交掉。

***
## 锁
在数据库有并发食物的时候，通过锁机制来保证访问的次序，已达到安全、保证数据一致性。

### 隔离级别 & 锁
| 隔离级别         | 锁                                                           |
| ---------------- | ------------------------------------------------------------ |
| read uncommitted | 读操作不需要加共享锁，这样就不会和写操作上的排他锁冲突       |
| read committed   | 读操作需要加共享锁，但是语句执行完成后会释放共享锁           |
| repeatable read  | 读操作需要加共享锁，但是只有在整个事务完成后才会释放共享锁   |
| serializable     | 限制性最强的隔离级别，__锁定整个范围的建__，并一直持有锁，直到事务完成 |

### 锁分类
#### 行锁
行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为行共享锁和行排他锁
###### 特点
> 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高

#### 表锁
表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享锁与排他锁
###### 特点
> 开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低

#### 页锁
页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
###### 特点
> 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

##### 总结
| 锁   | 开销 | 枷锁速度 | 死锁 | 冲突概率 | 并发速度 |
| ---- | :--: | :------: | :--: | :------: | :------: |
| 行锁 |  大  |    慢    |  会  |    低    |    高    |
| 表锁 |  小  |    快    | 不会 |    高    |    低    |
| 页锁 |  中  |    中    |  会  |    中    |   一般   |

### 锁的实现

### 锁的算法
InnoDB中锁的算法有三种：
- record lock：单个行记录上的锁
- gap lock：间隙锁
- next-key lock：record + gap 锁定一个范围，包含记录本身

##### 相关
- innodb对于行的查询使用next-key lock
- Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
- next-key lock为了解决Phantom Problem幻读问题
- 当查询的索引含有唯一属性时，将next-key lock降级为record key
- 有两种方式显式关闭gap锁：
    1. 将事务隔离级别设置为read committed
    2. 设置`innodb_locks_unsafe_for_binlog=1`

### 死锁
死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象

##### 解决
1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率

***
## 索引
索引是为了加快对数据的搜索速度而设立的。它能够改善检索操作的性能，但是会降低数据更改的性能。索引是scheme中的一个数据库对象，与表独立存放。索引的创建有两种情况：
- 自动：当在标上定义一个主键或者唯一约束条件时，oracle数据库会创建一个对应的唯一索引
- 手动：通过关键字创建索引

### 作用
- 在数据库中用来加速对表的查询，通过使用快速路径访问方法快速定位数据，减少磁盘IO

### 索引的触发方式
BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：
```
-- 只要它的查询条件是一个不以通配符开头的常量
select * from user where name like 'jack%'; 
-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： 
select * from user where name like '%jack'; 
```

### 索引的设计原则
- 适合索引的列是出现在where子句中的列，或者连接子句中指定的列
- 基数较小的类，索引效果较差，没有必要在此列建立索引
- 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
- 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。

### 索引的创建原则
- 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如`a=1 and b=2 and c>3 and d=4` 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- 较频繁作为查询条件的字段才去创建索引
- 更新频繁字段不适合创建索引
- 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
- 定义有外键的数据列一定要建立索引。
- 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
- 对于定义为text、image和bit的数据类型的列不要建立索引。

### 局部性原理
经常访问的数据和经常访问的代码往往会聚集在一起，局部性分为两种：
- 空间局部性：经常用的、经常被访问的数据会被尽快的放在一起
- 时间局部性：热点数据

### 磁盘预读
在读取磁盘文件时，即使是只读取一个字节的数据，也会将这个字节所属的页一起读取到内存中，一页为4KB

### 索引的分类
##### 主键索引
主键是一种唯一性索引，但它必须指定为 __PRIMARY KEY__，每个表只能有一个主键
##### 唯一索引
索引列的所有值都只能出现一次，即必须唯一，值可以为空
##### 普通索引
基本的索引类型，值可以为空，没有唯一性的限制
##### 全文索引
全文索引的索引类型为 __FULLTEXT__，全文索引可以在varchar、char、text类型列上创建
##### 组合索引
多个列组成一个索引，专门用于组合搜索

### 数据结构
MySQL采用B+树存储索引

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628132401.png)

##### 为什么用B+树不用hash表
- hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询
- hash索引不支持使用索引进行排序，原理同上
- hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性
- hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询
- hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低

##### 为什么用B+树不用B树
- B树只适合随机检索，而B+树同时支持随机检索和顺序检索
- B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素
- B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当
- B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作
- 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率

### 回表
在InnoDB中，是通过B+树结构对主键创建索引，然后在叶子结点中以key(主键)-value(记录)形式存储数据；如果没有主键，那么会选择唯一键；如果没有唯一键，那么会自动生成一个6位的row_id来作为主键。此时，如果某张表中的索引有非主键列，那么该索引的叶子结点中存储存储格式位：key(索引列)-value(主键)。在查找时，要先通过普通列索引找到对应的数据(key)和主键(value)，然后再根据主键查找主键索引拿到对应的记录。这种场景下会经过两次B+树(普通列索引+主键列索引)的遍历工作，这种行为被称为 __回表__

![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628132810.png)

### 索引覆盖
explain的输出结果Extra字段为Using index时，能够触发索引覆盖。通俗来讲就是 __只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。__
例如以下这张表：
``` 建表
create table user (
  id int primary key,
  name varchar(20),
  sex varchar(5),
  index(name)
)engine=innodb;
```
第一个SQL语句：`explain select id,name from user where name='zhangsan';`
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628132845.png)<br>
能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。

第二各SQL语句：`select id,name,sex from user where name='shenjian';`
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628132905.png)<br>
能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫码聚集索引获取sex字段，效率会降低。

### 联合索引
MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为：先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整

### 最左前缀 & 最左匹配
- 顾名思义，就是最左优先，在创建组合索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如`a=1 and b=2 and c>3 and d=4` 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- = 和 in 可以乱序，比如`a=1 and b=2 and c=3` 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

### 谓词下推

### 索引下推
在回表之前就已经根据条件对数据进行了一次删选和删除，从而提高执行的效率

***
## 日志
### redo log（前滚日志）
InnoDB存储引擎的日志文件，当发生数据修改的时候，InnoDB引擎会先将记录写到redo log中，并更新内存，此时更新就算完成了，同时InnoDB引擎会在合适的时机将记录持久化到磁盘中（WAL 预写日志），通过redo log的保证 __事务的持久性__，redo log是固定大小的，它是一个循环写的过程，循环写通过checkpoint和write pos两个指针实现，有了redo log之后，InnoDB就可以保证即使数据库发生异常重启，之前的记录也不会丢失，叫做：crash-safe

#### WAL预写日志
![clipboard](https://typroa12138.oss-cn-hangzhou.aliyuncs.com/image/20200628133129.png)

### undo log（回滚日志）
undo log是为了实现 __事务的原子性__，在MySQL数据库中InnoDB引擎中通过undo log来实现多版本并发控制，在操作任何数据之前，首先将数据备份到undo log中，然后进行数据库的修改，当出现了错误或用户执行了rollback语句时，系统可以根据undo log中的备份将数据恢复到食物开始之前的状态

#### undo log是逻辑日志，可以理解为
- 当执行delete语句时，undo log中会记录一条对应的insert语句
- 当执行insert语句是，undo log中会记录一条对应的delete语句
- 当执行update语句时，undo log中会记录一条对应相反的update记录

### binlog（归档日志）
binlog是server层的日志，主要做MySQL功能层面的事情，不管是什么存储引擎都可以使用biglog，它会记录所有语句的原始逻辑，并且采用追加写的方式。默认是关闭的，需要手动开启，并且可以指定记录方式（语句或行）。一般的数据备份系统可以通过备份binlog来实现数据备份。

#### 恢复数据过程
1. 找到最近的一次全量备份数据
2. 从备份时间点开始，将biglog取出来，执行SQL语句恢复数据

### 执行流程

***
## 执行计划

***
## 主从复制

***
## 调优
### 性能监控